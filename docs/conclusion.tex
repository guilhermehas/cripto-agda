\section{Conclusion}

Formal methods in cryptocurrency space are growing significantly.
Companies like \gls{iohk}, creator of Cardano, and Tezos are investing a lot in it.
This work contributes to the formal specification and definition of Bitcoin.

A good way of defining Bitcoin is by creating a model of it in a language with dependent types.
Agda looks like a good language for it, but other languages like CoQ, Lean can do this work too.

In this work, we define a lot of functionalities about Bitcoin.
There were definitions of transactions, transactions tree, block, and blockchain.
Most of the model definition was in transaction tree
because of the state of Bitcoin changes after every transaction.
There are other ways of doing the same thing,
but I thought that this way is easier to define.

Some part of this code is not just for modeling the Bitcoin,
but to validates inputs that can be wrong.
For example, transforming raw transactions into possible valid transactions.

\subsection{Future work}

In this work, there was a code that transforms a raw transaction into a possible valid transaction.
It is not a decidable function, because there is no definition of what it is an invalid transaction.
From future work, it should have a definition of what is an invalid raw transaction.
So it will avoid that valid transaction will be discarded. 

There is no definition of crypto functions like SHA-256 and elliptic curves in this work.
One thing that can be done is importing these functions from some Agda or Haskell packages.

In this cryptocurrency, there is no nonce and mining either.
But it is a feature easy to add.

This work does not have any IO operation.
So it is not possible to add transactions in the blockchain from the command line or the network.

The cryptocurrency of this work does not have any smart contract.
It would be good to define some of them in it.
