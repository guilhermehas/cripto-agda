%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% DOCUMENT PREAMBLE %%%
\documentclass[12pt]{article}

\include{style}
\usepackage{agda}
\usepackage{hyperref}
\usepackage{apacite}
\usepackage{catchfilebetweentags}

\usepackage{ucs}
\usepackage{amssymb}

\usepackage[english]{babel}
\usepackage{url}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{parskip}
\usepackage{fancyhdr}

\usepackage{vmargin}
\setmarginsrb{3 cm}{2.5 cm}{3 cm}{2.5 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}

\newcommand{\agda}[2]{\ExecuteMetaData[latex/#1.tex]{#2}}
\newcommand{\incgraph}[2]{\includegraphics[width=\columnwidth/#2]{imgs/#1}}
\newcommand{\incimgdiv}[3]{
  \begin{figure}
    \incgraph{#1.#2}{#3}
    \caption{#1}
    \label{fig:#1}
  \end{figure}
}
\newcommand{\incimg}[2]{\incimgdiv{#1}{#2}{1}}


\title{A Simplified version of Bitcoin, implemented in Agda}

% Title
\author{Guilherme H. A. Silva}
% Author
\date{15 de Abril de 2019}
% Date

\attr{university}{Fundação Getúlio Vargas}
\attr{universityinitials}{FGV}
\attr{professor}{Flávio Codeço Coelho}
\attr{mastertheme}{Modelagem Matemática}
\attr{author}{Guilherme Horta Alvares da Silva}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\pagestyle{fancy}
\fancyhf{}
\rhead{\theauthor}
\lhead{\thetitle}
\cfoot{\thepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\firstpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\pagebreak

\listoffigures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\thesection}{\arabic{section}}
\section{Introduction}

\subsection{Context} 

In 1983, David Chaum created ecash \cite{panurach1996money} an anonymous cryptographic eletronic money.
This cryptocurrency use RSA blind signatures \cite{chaum1983blind} to spend transactions.
Later, in 1989, David Chaum found an electronic money corporation called DigiCash Inc.
It was declared bankruptcy in 1998.

Adam Back developed a proof-of-work (PoW) scheme for spam control, Hashcash \cite{back2002hashcash}.
To send an email, the hash of the content of this email plus a nonce has to have a numerical value
smaller than a defined target.
So, to create a valid email, the sender (miner) has to spend a considerable CPU resource on it.
Because hash functions produce practically random values, so the miner has to guess a lot of nonce
values before finding some nonce that makes the hash of the email less than the target value.
This idea is used in Bitcoin proof of work because each block has a nonce guessed by the miner and
the hash of the block has to be less than the target value.

Wei Dai propose b-money \cite{dai1998b} for the first proposal for distributed digital scarcity.
And Hal Finney created Bit Gold \cite{wallace2011rise}, a reusable proof of work for hash cash for
its algorithm of proof of work.

On 31 October 2008, Satoshi Nakamoto registered the website ``bitcoin.org'' and put a link for his
paper \cite{nakamoto2008bitcoin} in a cryptography mailing list.
In January 2009, Nakamoto released the Bitcoin software as an open-source code.
The identity of Satoshi Nakamoto is still unknown.
Since that time, the total market of Bitcoin came to 330 billion dollars in 17 of December of 2018
when its value reached a historic peak of 20 thousand dollars.

Other cryptocurrencies like Ethereum \cite{wood2014ethereum}, Monero \cite{noether2015ring} and
ZCash \cite{hopwood2016zcash} were created after Bitcoin,
but Bitcoin is still the cryptocurrency with the biggest market value.

Ethereum is a cryptocurrency that uses an account model instead of UTXO used in Bitcoin for its
transaction data structure.
It uses Solidity as its programming language for smart contracts which resembles Javascript,
so it is easier to program in it than in the stack machine programming language of Bitcoin.
Ethereum is now transitioning from proof of work (used in Bitcoin) to proof of stake
which will be the default proof mechanism of Ethereum 2.0 and will be released in
3 of January of 2020.

Monero and ZCash are both cryptocurrencies that focus on fungibility, privacy and decentralization.
Monero uses an obfuscated public ledger, so anyone can send transactions,
but nobody can tell the source, amount or destination.
Zcash uses the concept of zero-knowledge proof called zk-SNARKs, which guarantee privacy for its users.

\section{Objectives}

\subsection{History}

Cryptocurrencies are used as money and used in smart contracts in a decentralized way.
Because of that, it is not possible to revert a transaction or undo the creation of the smart contract.
There is no legal framework or agent to solve a problem in case of the existence of a bug.
Because of that, the formal proofs are necessary in the cryptocurrency protocol.
So it can avoid big financial loss.

In the case of Bitcoin, if there is some problem in the source code,
it is possible to fix it using soft or hard forks.
In soft fork, there is an upgrade in the software that is compatible with the old software.
So it is possible the existence of old and new nodes in the same Bitcoin network.
In hard forks, all the nodes should be upgraded at the same time.
Because the newer version is not compatible with the older one.
So it is very dangerous to do this kind of fork.
Therefore in Bitcoin, this kind of fork never happened.

For example, in Bitcoin, the uniqueness of transaction IDs were not guaranteed.
To fix this problem, it should put the block number in the coinbase transaction.
This kind of change was solved in a soft fork named SegWit.

In Ethereum, there was a bug in DAO smart contract.
Because of that, malicious users exploited a vulnerability in it.
The total loss of this exploit was 150 million dollars on this day.
There was a hard fork to undo most of the transactions that exploited this contract.
This kind of hard fork violates the principle that smart contracts should be ruled just by
algorithms without any human intervention.
Because of that, the Ethereum blockchain that has not done the fork becomes the Ethereum classic.
It is the version of Ethereum that has never done a hard fork before.

\subsection{Proposes}

The objective of this work is to give a formal definition of what a cryptocurrency should be.
There are some different definitions of a cryptocurrency in this work,
but there are some formal proofs that they are the same.

In this work, it is possible to generate proofs transactions from transactions without proofs.
This means that a user can send a simple transaction without he worried to have to prove that
the transaction is right to put in the blockchain.
In Bitcoin, it happened in the same way.
Because the node has to verify the transactions.

\section{Relevant Background}

\subsection{Literature Review}

Before this work, there was some research in this field.
Beukema \cite{beukema2014formalising} was one of the first to try
to define a formal specification of Bitcoin.
In this work, he defines functions interfaces of Bitcoin and what they should do.
Most of these functions define how the Bitcoin Network protocol should be.
In his work, he does not utilize any programming language with dependent types like Agda or CoQ.
He uses mCRL2, a specification programming language.

Chaudhary \cite{chaudhary2015modeling} and his team have created a model of Bitcoin blockchain
in the model checker UPPAAL.
In his work, he calculates the probability of a malicious attack to succeed in doing a double spend.
For a small number of blocks, it is easier to do this attack.
Because of that, it is usually recommended that the user wait more blocks confirmations
after a big transaction.

Bastiaan \cite{bastiaan2015preventing} showed a stochastic model of Bitcoin using
continuous Markov chains.
In his work, he proposes a way of avoiding a 51\% attack in the network,
using two-phase proof of work.

Orestis Melkonian \cite{melkonian2019formalizing} in his masters have done the formal specification
of BitML (smart contract language) in Agda.
This language can be compiled to Script, the smart contract language of Bitcoin. 

Kosba \cite{kosba2016hawk} in his work made a programming language called Hawk for smart contracts.
This language uses formal methods to verify privacy using zero-knowledge proofs.
Using this language, the programmer does not have to worry about implementing the cryptography,
because the compiler generates automatically an efficient one.

Bhargavan \cite{bhargavan2016formal} translated Solidity and Ethereum bytecode into F*.
He verified that the Ethereum DAO bug was caught in its translation.
Nowadays, they have an implementation of Ethereum Virtual Machine (EVM) and Solidity in OCaml,
but they want to have a full implementation of EVM in F* too.

Luu \cite{luu2016making} built a symbolic execution tool named OYENTE to look for potential bugs.
In his work, he found a lot of contracts with real bugs.
One of these bugs was TheDAO bug, that caused a loss of 60 million dollars.
He used Z3 to find a potentially dangerous path of code.

Anton Setzer \cite{setzer2018modelling} also contributed to modeling Bitcoin.
He coded in Agda the definitions of transactions and
transactions tree of Bitcoin.
Orestis Melkonian start to formalize Bitcoin Script.

My work tries to extend Anton Setzer model and makes it possible to use the Bitcoin protocol
from inputs and outputs from plain text.
For example, the user sends a transaction in plain text to the software and it validates if it is correct.
To use the Anton Setzer model, the user has to send the data and the proof that are both valid.

\subsection{Agda Introduction}
Agda is a dependently typed functional language developed by Norell at Chalmers University of Technology
as his Ph.D. Thesis.
The current version of Agda is Agda 2.

  \subsubsection{Syntax}
  In Agda, \emph{Set} is equal to type.
  In languages with dependent types, it is possible to create a function that returns a type.

  \agda{agdaExamples}{funcType}

  After the function name, it is two colon (\emph{:}) and the arguments of the function.
  It is closed by \emph{(name\_of\_argument : type\_of\_argument)}.
  After all, there is one arrow and the type of the result of the function.
  This ``if, then, else'' is not a function built-in in Agda.
  It is a function defined this way \emph{if\_then\_else\_} .

  So it is possible to use this function in the default way.

  \agda{agdaExamples}{funcTypeUnd}

  Or use the arguments inside the underscore.

  \agda{agdaExamples}{funcType2}

  The same notation can be done using just arrows without naming the arguments.

  Because of dependent types, it is possible to have a type that depends on the input.

  \agda{agdaExamples}{dependentType}

  It is possible in Agda to do pattern match.
  So it breaks the input in cases.

  \agda{agdaExamples}{patternMatch}

  To create a new type with a different pattern match, it is used the data constructor.

  \agda{agdaExamples}{dataConstructor}

  This is another example of \emph{Data Set}, but it depends on the argument.

  \agda{agdaExamples}{vector}

  \emph{Vector zero} is a type of a vector of size zero, so the only option to construct it is the empty vector.
  It is constructed from the first constructor.
  Other types of vectors like \emph{Vector 1} (vector of size one), \emph{Vector 2}, ... can only be constructed by
  the second constructor.
  It takes as argument a natural number and a vector and returns a vector with the size of the last vector
  plus one.

  Records are data types with just one case of pattern match.

  \agda{agdaExamples}{record}

  The constructor is the name of the data constructor.

  Implicits terms are elements that the compiler is smart enough to deduce it.
  So it is not necessary to put it as an argument of the function.

  \agda{agdaExamples}{id}

  Implicits arguments are inside \emph{\{\}}.
  In this example, the name of the Set (\emph{A}) can not be omitted
  (like the second function version of boolean to set),
  because it is used to say that \emph{x} is of type \emph{A}.

  In the case of the function \emph{id}, the type of input can be deduced by the compiler.
  For example, the only type that \emph{zero} can be is Natural.

  \agda{agdaExamples}{idNat}

  Functions in Agda can be defined in two ways

  \agda{agdaExamples}{funcs}

  In the first case, the arguments are before equal sign (\emph{=}).
  In the second way, it is used the lambda abstraction that means the same thing.

  \subsubsection{Lambda Calculus}
  Lambda Calculus is a minimalist Turing complete programming language with the concept of abstraction,
  application using binding and substitution. For example, \emph{x} is a variable, $(\lambda x.M)$
  is an Abstraction and (\emph{M N}) is an Application.

  In Lambda Calculus, there are two types of conversions $\alpha$-conversion and $\beta$-reduction.
  In $\alpha$-conversion, $(\lambda x.M[x]) \rightarrow (\lambda y.M[y])$.
  So in every free variable in \emph{M} will be renamed from \emph{x} to \emph{y}.
  For \emph{M[x] = x}, an $\alpha$-conversion is $(\lambda x.x) \rightarrow (\lambda y.y)$

  A free variable is every variable that is not bound outside.
  For example, $((\lambda\textcolor{green}{x}.\textcolor{blue}{x}) \textcolor{red}{x})$.
  The \textcolor{blue}{blue x} is binded for the \textcolor{green}{green x},
  but the \textcolor{red}{red x}
  is not binded for any function. So the \textcolor{red}{red x} is a free variable.

  In $\beta$-reduction, it replaces the all free for the expression in the application.
  The $\beta$-reduction of this expression $((\lambda x.M) N) \rightarrow (M[x := N])$ .
  So if $M = x$, the $\beta$-reduction will be $((\lambda x.x) N) \rightarrow N$.
  If $M = (\lambda x.x) x$, the $\beta$-reduction will be
  $(\lambda x.((\lambda x.x)x))N \rightarrow (\lambda x.x)N$.

  Agda uses typed lambda calculus.
  So in an application \emph{(M N)}, \emph{M} has to be of type $A \Rightarrow B$ and N has to be of type A.
  $(\lambda (x : A) . x)$ is of type $A \Rightarrow A$, because \emph{x} is of type \emph{A}.

  \agda{lambdaCalculus}{Id}
  The simplest function is the identity function made in Agda.

  \agda{lambdaCalculus}{Id2}
  This is another way of writing the same function.

  \agda{lambdaCalculus}{trueFalse}
  This is how true and false are encoded in lambda calculus.

  \agda{lambdaCalculus}{naturals}
  This is how naturals numbers are defined in lambda calculus.
  Look that the definition of zero looks like the definition of false.

  \agda{lambdaCalculus}{isZero}
  Defining natural numbers in this way, it is possible to say if a natural number is zero or not.

  \agda{lambdaCalculus}{plus}
  Plus is defined this way using lambda calculus.

  \agda{lambdaCalculus}{onePone}
  This is one example of the calculation of one plus one in Lambda Calculus.

  \agda{lambdaCalculus}{list}
  This is how lists are defined in Lambda Calculus.

  \agda{lambdaCalculus}{sumList}
  Substituting the cons operation of list per plus and nil list to zero, it is possible to calculate
  the sum of the list.

  \agda{lambdaCalculus}{either}
  In this way, it is possible to define \emph{Either}.
  It is one way to create a type that can be a Natural or a Boolean.

  \agda{lambdaCalculus}{eitherExamples}
  In these examples, it is defined zero, one in left and false, true in right.

  \agda{lambdaCalculus}{eitherRes}
  \emph{Either} is useful when defining one function that works for left and another that works for the right.
  The function chosen for left was if a natural number is zero and
  the function chosen for right was if the identity function.

  \agda{lambdaCalculus}{tuple}
  This way is how tuple is defined in Lambda Calculus.

  \agda{lambdaCalculus}{tupleExamples}
  This is how is defined the tuple zero false and the tuple one true.

  \agda{lambdaCalculus}{tupleAdd}
  This is one way of defining a function that adds one to the argument
  if the first element of the tuple is true.


  \subsubsection{Martin-Löf type theory}
  Agda also provides proof assistants based on the intentional Martin-Löf type theory.

    In Martin-Löf type theory, there are 3 finite types and 5 constructors types.
    The 0 type contain 0 terms, it is called empty type and it is written bot.
    \agda{agdaExamples}{botType}

    The 1 type is the type with just 1 canonical term and it represents existence.
    It is called unit type and it is written top.
    \agda{agdaExamples}{trivialType}

    The 2 type contains 2 canonical terms. It represents a choice between two values.
    \agda{agdaExamples}{eitherType}

    The Boolean type is defined using the Trivial type and the Either type.
    \agda{agdaExamples}{boolType}

    If statement is defined using booleans.
    \agda{agdaExamples}{ifThenElse}


    \subsubsection{Types Constructors}
    The sum-types contain an ordered pair.
    The second type can depend on the first type.
    It has the same meaning of exist.
    \agda{agdaExamples}{sumType}

    The $\pi$-types contain functions.
    So given an input type, it will return an output type.
    It has the same meaning as a function:
    \agda{agdaExamples}{piType}

    In Inductive types, it is a self-referential type.
    Naturals numbers are examples of that:
    \agda{agdaExamples}{Nat}
    Other data structs like linked list of natural numbers, trees, graphs are inductive types too.

    Proofs in inductive types are made by induction.
    \agda{agdaExamples}{NatElim}

    Universe types are created to allow proofs written in all types.
    For example, the type of \emph{Nat} is \emph{U0}.


It looks like CoQ, but does not have tactics.
Agda is a total language, so it is guaranteed that the code always terminal and coverage all inputs.
Agda needs it to be a consistent language.

Agda has inductive data types that are similar to algebraic data types in non-dependently
typed programming language.
The definition of Peano numbers in Agda is:

\agda{agdaExamples}{Nat}

Definitions in Agda are done using induction.
For example, the sum of two numbers in Agda:

\agda{agdaExamples}{sum}

In Agda, because of dependent types, it is possible to make some restrictions in types that are not
possible in other languages.
For example, get the first element of a vector.
For it, it is necessary to specify in the type that the vector should have at size greater or equal
then that one.

\agda{agdaExamples}{vecHead}

Another good example is that in the sum of two matrices, they should have the same dimensions.

\agda{agdaExamples}{matrixSum}


\subsection{Bitcoin}

The Bitcoin was made to be a peer to peer electronic cash.
It was made in one way that users can save and verify transactions without the need of a trusted party.
Because of that no authority or government can block the Bitcoin.

\incimg{transactions1}{png}
%% https://medium.com/coinmonks/bitcoin-transactions-be401b48afe6

Transactions in Bitcoins (like in FIG1) are an array of input of
previous transactions and an array of outputs.
Each input and output is an address, each address is made from a public key
that is made from a private key.

\incimg{privatekey}{png}
%% https://coinsutra.com/bitcoin-private-key/

A private key is a big number.
It is so big that it is almost impossible to generate two identicals private keys.

The public key is generated from the private key (like in FIG2 where account number is f(p)), 
but a private key can not be generated from a public key.

The mining transaction does require an input.
For each input of the transaction, it is necessary a signature signed with a private key
(like in FIG2 where signature is f(p,t))
to prove the ownership of the Bitcoins.
With the message and the signature, it is possible to know that the owner of the private key
that generates the public key signed this message.

With the signature and the public key, it is not possible to know the private key.
In FIG2, the checker is a f(t,s,a).
So because of that, the owner of the private key can sign several messages without anyone knows
his private key.

\incimg{transactions2}{jpg}
%% https://en.wikipedia.org/wiki/Bitcoin_network

Transactions (shown in FIG3) are grouped in a block (shown in FIG4).
Each block contains in its header the timestamp of its creation, the hash of the block,
the previous hash and a nonce.
A nonce is an arbitrary value that the miner has to choose to make the hash of the block respect some
specific characteristics.

\incimg{blockchain}{png}
%% https://bitcoin.stackexchange.com/questions/12427/can-someone-explain-how-the-bitcoin-blockchain-works/13347
%% https://i.stack.imgur.com/HrKX0.png

Each block has a size limit of 1 MB.
Because of that, Bitcoin forms a blockchain (a chain of blocks).
Each block should be created in an average of 10 minutes.
This time was chosen because 10 minutes is enough to propagate the block throughout the world.
To make the blockchain tamper-proof, there is a concept called proof of work in Bitcoin.
So the miner has chosen a random value as nonce that makes the hash of the block less
then a certain value.
This value is chosen in a way that each block should be generated on 10 minutes in average.
If the value is too low, miners will take more time to find a nonce that make the hash block
less than it.
If it is too high, it will be easier to find a nonce and they will find it faster.

When two blocks are mined in nearly the same time, there are two valid blockchains.
It is because the last block in both blockchains are valid but different.
Because of this problem, in the Bitcoin protocol, the largest chain is always the right chain.
While two valid chains have the same size, it is not possible to know which chain is the right.
This situation is called fork and when it happens, it is necessary to wait to see in which chain
the new block will be.

In Bitcoin, there is a possibility of a 51\% attack.
It happens when some miner, with more power than all network, mine secretly the blocks.
So if the main network has 50 blocks, the miner could produce hidden blocks from 46 to 55
and he would have 10 hidden blocks from the network.
When he shows their hidden blocks, his chain become the valid chain, because it is bigger.
So all transactions from previous blockchain from 46 to 50 blocks become invalid.
Because of that, when someone makes a big transaction in the blockchain, it is a good idea
to wait more time.
So it is becoming harder and harder to make a 51\% with more time.
Bitcoin has the highest market value nowadays, so attacking the Bitcoin network is very expensive.
Nowadays, this kind of attack is more common in new altcoins.

\incimgdiv{wallet}{png}{2}
%% https://trustwallet.com/buy-bitcoin/

Wallet (shown in \ref{fig:account}) is software that tracks all transactions 
that the users received and sent.
It also makes new transactions from previously received transactions.

\subsection{Ethereum}

Ethereum differs from Bitcoin in having an Ethereum Virtual Machine (EVM) to run script code.
EVM is a stack machine and Turing complete while Bitcoin Script is not
(it is impossible to do loops and recursion in Bitcoin).

Transactions in Bitcoin are all stored in the blockchain.
In Ethereum, just the hash of it is stored in it.
So it is saved in the off-chain database.
Because of that, it is possible to save more information in Ethereum Blockchain.

In Bitcoin, the creator of the contract to pay the amount proportional to its size.
In Ethereum, it is different, there is a concept of gas.
Each smart contract in Ethereum is made by a series of instructions.
Each instruction consumes different computational effort.
Because of that, in Ethereum, there is a concept of gas, that measure how much computational effort
each instruction needs.
So in each smart contract, it is well know how much computational effort will be necessary to run it
and it is measured in gas.
Because computational effort is a scarce resource, to execute the smart contract, it is necessary to
pay an amount in Ether for each gas to the miner run it.
Smart contracts that pay more ether per gas run first because the miner will want to have the best
profit and they will pick them.
If the amount of ether per gas paid is not high enough, the contract will not be executed,
because some other contracts pay more that will be executed instead of this one.

Because Ethereum has its EVM with more instructions than Bitcoin and it is Turing Complete,
it is considered less secure.
Ethereum has its high-level programming language called Solidity that looks like Javascript.

\section{Bitcoin UTXO}

The UTXO model used in Bitcoin and the account model used in Ethereum are the two most used kinds
of data structures to model accounts records and savings states.

\incimg{account}{jpeg}
%% https://medium.com/@sunflora98/utxo-vs-account-balance-model-5e6470f4e0cf

In the account model, it is saved the address and the balance of each address
(like in FIG6).
For example, the data structure will look like this [(0xabc01, 1.01), (0xabc02, 2.02)].
So the address 0xabc01 has 1.01a of balance and the address 0xabc02 has 2.02 of balance.
In this way, it is possible to easily know how much balance each address has,
but it is not possible to know how they got in this state.

  \incimg{utxo}{png}
  %% https://bitcoin.org/
  %% https://medium.com/@sunflora98/utxo-vs-account-balance-model-5e6470f4e0cf

In the UTXO model (shown in FIG7), each transaction is saved in the transaction tree.
Every transaction is composed of multiples inputs and multiples outputs.
But all inputs have to never been spent before.

Because of that, in the UTXO model, it is easy to make a new transaction from the previous one,
but it is harder to know how much each one has.
The wallet that calculate how much balance each address has.

In the account model, there could be one kind of vulnerability that is less probable to happen in UTXO
model.
Because there is an undesirable intermediary state that there is some address without balance while
another has not already received his money.

For example: \\
\textbf{
bobBalance -= 1 \\
Intermediary State \\
aliceBalance += 1
}

In the account model, it is straight forward to know how much balance each address has.
In the UTXO model, this calculation is made off-chain. It can be a good thing,
because each user has more privacy.

\section{Crypto Functions}
The first thing that we define is the crypto functions that will be needed to make the cryptocurrency.
Messages can be defined in multiple ways, one array of bytes, one string or a natural number.
Messages in this context means some data.

The private key is a number, a secret that someone has.
In Bitcoin, the private key is a 256-bit number.
A private key is used to signed messages.

The public key is generated from a private key.
But getting the private key from a public key is impossible.
To verify who signed a message with a private key, he has to show the public key.

Hash is an injection function (the probability of collision is very low).
The function is used from a big domain to a small domain.
For example, a hash of big file (some GBs) is an integer of just some bytes.
It is very useful to prove for example that 2 files are equal.
If the hash of two files are equal, so the files are equal.
It is used in torrents clients, so it is safe to download a program to untrusted peers,
just have to verify if the hash of the file is equal to the hash of the file wanted.

These functions can be defined, but it is not the purpose of this theses.
So they will be just postulates.

\agda{Crypto}{cryptoPostulates}

\section{Transactions}

\subsection{Definitions}

In Bitcoin, there are some transactions.
In each transaction, there are multiple inputs and outputs.
Each input is named TXFieldWithId.
The input of one transaction is the output of another transaction.
Firsts outputs are generated from coinbase transaction (there is just one of this transaction at
each block).
Coinbase transactions are the miner reward.

\agda{Transactions}{VectorOutput}

Vector output is the vector of outputs transactions.
It is a non-empty vector.
In its representation, it is possible to know in what time it was created (time is the position of
they in all transactions),
what is his size (quantity of outputs fields)
and the total amount spent in this transaction,

\emph{elStart} is proof that the position of TXFieldWithId is the last one.
It is used after to specify which input is in the transaction.

\agda{Transactions}{TXSigned}

A signed transaction is composed of a non-empty list of inputs and outputs.
For each input, there is a signature that confirms that he accepted every output in the list of outputs.
And in the transaction, there is proof that the total amount of money in all inputs are bigger than
the total amount of outputs.
The remainder will be used by the miner.

\subsection{Raw Transaction}

Raw transactions are transactions without any explicit dependent type.
Here the definition of \emph{raw signed transaction}:

\agda{RawTransactions}{rawtxsigned}

\emph{Raw signed transactions} is a record with \emph{inputs}, \emph{outputs}
and the signature of \emph{inputs} and \emph{outputs}.

The definition of \emph{Raw Input}:

\agda{RawTransactions}{rawinput}

In each input, it is necessary to know the time, the position of it in the transaction,
the amount spent, its message, the signature, and its public key.
The signature is the signature of the message.
And the message is usually related to the amount spent in each output.

The definition of \emph{raw transaction}:

\agda{RawTransactions}{rawTransaction}

It is all inputs and all outputs.

The definition of \emph{Raw TX}:

\agda{RawTransactions}{rawTX}

The definition of \emph{raw transaction coinbase}:

\agda{RawTransactions}{rawCoinbase}

The defintion of \emph{raw Vector Output}: 

\agda{RawTransactions}{rawVecOut}

It has the time, its size, the total amount, the \emph{vector output}
and proof that this vector is the same as the list of outputs of this type.

The definition of the record that every input transaction is signed in a given time:

\agda{RawTransactions}{txsigall}

It has the size of vector output, the sublist of all inputs, the total amount,
the \emph{vector output} and a proof that all sublist of inputs are signed.

To get the proof that the transaction is signed from the raw transaction:

\agda{RawTransactions}{rawtxSigToTxsigAll}

It has to validate first that the \emph{list of outputs} is a valid \emph{Vector Output}.
Second, it validates if the signature of the inputs are valid with the
\emph{raw signed transaction}.
In the last case, it validates if the time of the \emph{vector output} is equal
of the time of this transaction.
If all conditions match, it returns a proven signed transaction.
If not, it returns nothing.

This function transforms a \emph{raw transaction} into a \emph{signed transaction}:

\agda{RawTransactions}{txrawToTxsig}

The first function returns a proof that the \emph{vector output} is equal to the total amount of
the \emph{list of transactions}.
It is impossible that the \emph{vector output} is equal to an empty list.
In case that the list has just one element, it just has to return \emph{refl}.
The another case, it is done recursively.

The proof that the amount of input transaction is greater than the amount of output
is just a rewrite from the previous proof.

The function of \emph{same message} returns a proof that the message of \emph{raw transaction}
is the same as the message of the \emph{vector output}.
In case that \emph{vector output} has just size one or two, it is a trivial case.
The other cases are doing it recursively.

\emph{sigPub} is another function that returns a proof that an input message is signed.
It validates it with its public key.

The last function returns a proof that every input was signed.
It is done in a recursive way using the function \emph{sigPub}.

This is the function that transforms a list ot transactions into a possible \emph{vector output}:

\agda{RawTransactions}{listTXFieldtoVecOut}

The list has to be at least with a size one.
Because the \emph{vector output} can not be empty.
To add one element into the vector, it has to verify if the time is equal to the first time.
Another verification is that the informed position in the vector is right.
If all validations are right, it returns the vector output.
If it is not, it returns nothing.

The definition of the function that transform a \emph{raw transaction} into a
\emph{signed transaction}:

\agda{RawTransactions}{rawtoTXSigned}

The first validation that the function does is verifying that the outputs are not empty.
Another validation is verifying if the amount spent on inputs is greater than the amount of the outputs.
The function \emph{Signed?}, defined in the crypto library, validates if the
message was signed with the input.
After, it validates if all inputs are signed.
If all validations are right, it returns the \emph{raw transaction signed}.
If it is not, it returns nothing.

\section{Transaction Tree}

\subsection{Definition}

The transaction tree is one of the most important data structures in Bitcoin.
In the transaction tree, there are all unspent transaction outputs (UTXO).
In every new transaction, the UTXOs used as input is removed from the transaction tree.

\agda{TXTree}{TXTree}

In this implementation, time is the number of transactions in TXTree.
Block is related to which block the transaction tree is.
After every new coinbase transaction (the miner transaction), the block size increment in one quantity.
Total fees are how much the miner will have in fee of transactions if he makes a block with these
transactions.
Quantity of transactions is how many transactions there are in the current block.
The type is tQtTxs instead of a natural number because, in this implementation, each block can have
a number maximum of transactions.
In Bitcoin, it is different, each block has a limit size in space of 1 MB.

Genesis tree is the first case.
It is when the cryptocurrency was created.
\emph{txtree} is created from another tree.
\emph{proofLessQtTX} is proof that the last transaction tree has its
block size less than the maximum block size minus one or it is a coinbase transaction.
It is because it is necessary to verify the size of the last \emph{txtree} so it will not have
the size greater than the maximum.

\agda{TXTree}{TX}

TX is related to the transaction done in the cryptocurrency.
There are two kinds of transaction.
Coinbase transaction is the transaction done by the miner.
In coinbase, they have just outputs and do not have any input.
\emph{pAmountFee} is proof that the output of the coinbase transaction is equal to the total fees plus
a block reward.

Another kind of transaction is the \emph{normalTX}, a regular transaction.
\emph{SubInputs} are a sub-list of all unspent transaction outputs of the previous transaction tree.
Outputs are the new unspent transaction from this transaction.
So who receives the amount from this transaction can spend it after.
\emph{TxSigned} is the signature that proves that every owner of each input approve this transaction.
In \emph{TxSigned}, there is proof that the output amount is greater than the input amount too.

\agda{TXTree}{isCoinBase}

This function just returns trivial type if coinbase and bot type if not.

\agda{TXTree}{nextBlock}

If it is a normal transaction, the block continues the same.
If it is a coinbase transaction, the next transaction will be in a new block.

\agda{TXTree}{incQtTx}

This function is to increment the number of transactions in the block.
It has to receive proof that the quantity of transaction that was before this new transaction was
less than then the maximum quantity of transactions allowed.
So it is guaranteed that the number of transactions will never be greater than the maximum allowed.
If it is a coinbase transaction, it will be a new block.
So the number of transactions starts being zero.

\agda{TXTree}{incFees}

\emph{IncFee} is a function that increments how much fee the miner will receive.
If it is a coinbase transaction, the fee will be received by the miner,
so the next miner will not receive this previous fee.
Because of that, the new fee will start from zero.
If it is a normal transaction, the newest fee will be the amount of input of the transaction minus
the output of this transaction plus the last fee of previous transactions.

\agda{TXTree}{outFee}

\emph{outFee+RewardBlock} is proof that the amount of output transactions is equal to total fees of
other transactions plus the block reward.

\subsection{Raw Transaction Tree}

The raw transaction tree is the tree without the explicit types.
Here, the definition:

\agda{RawTXTree}{rawtxtree}

A good utility of raw data types is that it is not necessary to add type arguments in functions.
Here, a function that adds a transaction to a transaction tree.
If this transaction is compatible with the transaction tree,
it returns a new transaction tree.
If it is not compatible, it returns nothing.
A better solution is a proof that this transaction is invalid with the transaction tree
instead of nothing.
But defining what is an invalid transaction can be tricky.

\agda{RawTXTree}{addtxtree1}

There are two cases.
The first one is if the transaction is a coinbase transaction.
It tries first to transform a list of \emph{TXField} into \emph{VecOut}.
If it can not transforms, it returns nothing.
If it can, it validates if the amount of vector output is equal to total fees plus the block reward.
After, it validates if the time of the transaction is equal to the time of the transaction tree.
In the end, it adds the outputs of the transaction to the vector of outputs.
Because it is a coinbase transaction, there are no inputs to be removed.

\agda{RawTXTree}{addtxtree2}

The second case, that the transaction is regular, looks like the same.
First, it validates if the quantity of transaction is less than the maximum allowed.
Second, it validates if this transactions is a valid signed transaction.
If all these conditions are true, it returns a new transaction tree
with news outputs equal to the outputs of this transaction plus the outputs of the last transaction tree
minus the inputs.
In case of an invalid transaction, it returns nothing.

\subsection{Proofs}

One of the important proofs is that each output of \emph{outputs transaction} is distinct.
This is very important because it guarantees that each input in the transaction could be
just related to just one unspent output.
This characteristic could be in the type of transaction tree,
but it is proven outside of it.

First, it is necessary to define what is a distinct union:

\agda{Utils}{uniondist}

The union of distinct lists makes a new distinct list if both are distinct to each other.

Now, to prove that outputs are a distinct list:

\agda{proofsTXTree}{uniqueouts}

In the first case, the transaction tree is a genesis tree without any outputs.
So an empty list is a distinct list.
In the second case, the outputs are the union of inputs of the transaction with the outputs
of \emph{vector output}.
So, it is necessary to prove that inputs of the transaction are distinct,
that elements of \emph{vector output} are also distinct and that both lists are distinct to each other.

\agda{proofsTXTree}{distinps}

There are some cases to prove that inputs are distinct.
First, if it is a regular transaction or if it is a coinbase transaction.
Second, if the transaction tree of this transaction is a genesis tree or if it is a regular tree.

If the transaction tree of the transaction is a genesis tree,
the number of inputs is zero.
So they are distinct.

In other cases, it does the same thing as proof of unique outputs.
The only difference is that it also does a recursive proof.
It assumes that the transaction of the last transaction tree is also distinct.

\agda{proofsTXTree}{alldists}

Both are distinct to each other because all of the transactions of input has the timeless
then the time of the transaction.
And because all of the outputs of the current transaction has time equal to the current time
of this transaction.

\agda{proofsTXTree}{outtimeless}

The proof that the time of the outputs is less than the current time of the transaction
is done recursively.
It is both necessary to proof that \emph{inputs of tx} and \emph{vector output} have both
times less than the current time of this transaction.
It is all done recursively.


\section{Ledger}

Ledger in the cryptocurrency is like a wallet.
It makes it easier for users to send their coins or to know how much money they have in total.

Here, the definition of how much money the user has in the last tree:

\agda{Ledger}{ledgertree}

The definition of \emph{ledgerOut}:

\agda{Ledger}{ledgerout}

If there is no output, it returns zero of the amount.
If there is at least one output, it verifies if the output address is the same as the address.
If it is, it adds the amount to the amount of the rest of the outputs.
If it is not, it just returns the result of the recursion of the rest of the outputs.

Here, the same code for list of outputs without id:

\agda{Ledger}{ledgernoid}

\section{Blockchain}

\subsection{Definition}

Block is a chain of transactions that is added in Bitcoin blockchain in every ten minutes.
Each block consists of several transactions and a miner transaction.
This is how a block is defined in this work:

\agda{Blockchain}{block}

\emph{nextTXTree} assures that the second transaction tree is from the first transaction tree.
\emph{firstTreesInBlock} guarantees that the last transaction in the first transaction tree
is the first in the block.
\emph{coinBaseTree} assures that the last transaction in the second transaction tree is
a coinbase transaction.

Blockchain is a chain of valid blocks.
Every new block must be a continuation of the previous one.
Here is the definition of the blockchain:

\agda{Blockchain}{blockchain}

In the first case, blockchain just has one block, called \emph{fstBlock}.
In the second case, the blockchain is an addition of a valid block from a previous blockchain.

\subsection{Creation}

To create a blockchain, it is first needed to create the last block.
From the last block, it is possible to create all the chain.

\agda{Blockchain}{blockblockchain}

In this proof, if the first transaction tree of the block is a genesis tree,
it will return a blockchain of just one block.
If it is a regular tree, it tries to find the first transaction tree of this block.
Using a recursive definition of block to blockchain,
it is possible to generate all the rest of this blockchain from this block.

It is not always possible to generate a block from the transaction tree.
It is because the last transaction of a transaction tree must be a coinbase transaction.
Here, the function that returns a decidable if it is possible to generate a block from
the transaction tree.

\agda{Blockchain}{treeblock}

The definition of the raw block gets just the coinbase transaction tree as an explicit type.
The other transaction tree can be founded opening the record.

\agda{Blockchain}{rawblock}

The code of the definition of what is a coinbase tree:

\agda{Blockchain}{coinbasetree}

The definition of a coinbase tree is the one that the last transaction is a coinbase.

The code verifies if the last transaction tree is a coinbase tree:

\agda{Blockchain}{iscoinbase}

If it is, it returns that it is possible to create a block from that with the block definition.
If it is not, it returns that it is impossible to create a block from this transaction tree.

But to create a block from this coinbase transaction tree, it is necessary to find the first tree
of the block.

\agda{Blockchain}{fsttree}

The definition of \emph{fstTree} is that it has a tree that is before this tree in the type.
And this tree before is the first in the block.

\agda{Blockchain}{firsttreeinblock}

The decidable version of this \emph{Set}:

\agda{Blockchain}{isfirsttreeinblock}

In this case, it pattern match trees that are genesis tree or if the last transaction was a coinbase
transaction.

\agda{Blockchain}{firsttree}

To find the first tree in the block, there are two cases.
The first case is that if the tree is a genesis tree, so the result is itself.
The second case is if it a regular tree, so it still has to divide it in many cases.
If this tree is already the first tree in the block, it will return itself.
If this tree is not, it has to verify if the block number of the tree is the same as this tree.
If the block number is equal, it can recursively find the first tree.
If it is not, it has to provide proof that this tree must be
the first and the blocks numbers are different.

To define what it means of one tree is next to another:

\agda{Blockchain}{nexttree}

There are two cases. If both trees are the same, they are next to each other.
If there is a proof that both trees are next to each other and
if there is one tree that was generated from the last one,
so the first tree is next to the last one.

\section{Conclusion}

This text has shown the definition of Bitcoin protocol.
Definitions of transactions, transactions tree, block, and blockchain.
In this work, it was also made the code that transforms raw transactions in a possible valid transaction,
to incorporate it in the transaction tree.

\subsection{Future work}

In this work, there was a code that transforms a raw transaction into a possible valid transaction.
It is not a decidable function, because there is no definition of what it is an invalid transaction.
From future work, it should have a definition of what is an invalid raw transaction.
So it will avoid that valid transaction will be discarded. 

There is no definition of crypto functions like SHA-256 and elliptic curves in this work.
One thing that can be done is importing these functions from some Agda or Haskell packages.

This work does not have any IO operation.
So it is not possible to add transactions in the blockchain from the command line or the network.

The cryptocurrency of this work does not have any smart contract.
It would be good to define some of them in it.

\newpage

\bibliographystyle{apacite}
\bibliography{References}

\end{document}
